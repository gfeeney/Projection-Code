sex <- "male"
out <- modified.midpoint.interpolation(BaseASD[20 + 1:20, j], adjfac)
if (out$ssd > 0.001) {
stop("modified.midpoint.interpolation: out$ssd > 0.001")
}
BaseASDsy[96 + 1:96, j] <- out$table2[, "y3+"]
}
BaseASDsy[, 1] - apply(BaseASDsy[, 2:48], 1, sum)
CFA <- BaseASDsy[, 1] / apply(BaseASDsy[, 2:48], 1, sum)
CFA
BaseASDsy[, 2:48] <- BaseASDsy[, 2:48] * matrix(CFA, nrow = length(CFA), ncol = 47)
BaseASDsy[, 1] - apply(BaseASDsy[, 2:48], 1, sum)
CFA <- BaseASDsy[, 1] / apply(BaseASDsy[, 2:48], 1, sum)
CFA
saveRDS(BaseASDsy, paste0(path2inputs, "BaseASD/BaseASDsy.rds"))
write.csv(BaseASDsy, paste0(path2inputs, "BaseASD/BaseASDsy.csv"))
# Plot interpolated distributions
pathfile <- paste0(path2inputs, "BaseASD/plots/BaseASDsyPlots.pdf")
pdf(file = pathfile, onefile = TRUE)
for (j in 1:dim(BaseASDsy)[2]) {
place <- colnames(BaseASDsy)[j]
sex <- "female"
y <- BaseASDsy[1:96, j]
x <- 1:length(y) - 0.5
plot(x, y)
lines(x, y)
text(0, 0, paste(place, sex), adj = 0)
sex <- "male"
y <- BaseASDsy[96 + 1:96, j]
plot(x, y)
lines(x, y)
text(0, 0, paste(place, sex), adj = 0)
}
dev.off()
metadata <- readRDS("metadata.rds")
path2inputs <- metadata$paths$path2inputs
places <- metadata$place$places
library(xlsx)
# STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1 STEP 1
# Import extrapolated TFRs from .xls files
path <- paste0(path2inputs, "ASBR/src/TFR_Pasex/")
filenames <- dir(path)
filenames
TFRlist <- vector(mode = "list", length = length(filenames))
names(TFRlist) <- metadata$place$places
for (i in 1:length(filenames)) {
pathfile <- paste0(path, filenames[i])
x <- read.xlsx(pathfile, sheetName = "INPUT", startRow = 5, endRow = 34, colIndex = 3:4)
TFRs <- x[, 2]
names(TFRs) <- x[, 1]
TFRlist[[i]] <- TFRs
i <- i + 1
}
TFRlist
pcycles <- metadata$time$pcycles
TFRmid <- function(x, pcycles) {
lo <- x[c("2022", "2027", "2032", "2037", "2042")]
hi <- x[c("2023", "2028", "2033", "2038", "2043")]
TFR <- (lo + hi) / 2
names(TFR) <- pcycles
return(TFR)
}
TFR <- do.call(rbind, lapply(TFRlist, TFRmid, pcycles))
rownames(TFR) <- metadata$place$places
TFR
saveRDS(TFR, paste0(path2inputs, "ASBR/TFR.rds"))
# STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2 STEP 2
# Read in 2019 census ASBR estimates
pathfile <- paste0(path2inputs, "ASBR/src/Census2019ASBRestimates.xlsx")
x <- read.xlsx(pathfile, sheetName = "main", colIndex = 1:8)
rownames(x) <- as.character(x[, 1])
x <- as.matrix(x[, -1])
colnames(x) <- c("15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49")
CensusASBRs <- x
CensusASBRs
saveRDS(CensusASBRs, paste0(path2inputs, "ASBR/CensusASBRs.rds"))
# STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3 STEP 3
# Calculate ASBR projection input list from TFR and CensusASBRs
# SRB <- rep(1.03, times = 48)  # Be sure this is what we want
# Following data received 27-Sep-2021 from Paul Waweru Ngogi via Telegram msg
pathfile <- paste0(path2inputs, "ASBR/src/20210927-SexRatioatBirth2019.xlsx")
x <- read.xlsx(pathfile, sheetName = "main", colIndex = 1:2)
SRB <- x[, 2]
places <- metadata$place$places
names(SRB) <- places
SRB
ASBRn <- CensusASBRs  # Normalized ASBRs
ASBRn[ , ] <- 0
for (i in 1:dim(CensusASBRs)[1]) {
ASBRn[i, ] <- CensusASBRs[i, ] * 0.2 / sum(CensusASBRs[i, ])
}
places <- metadata$place$places
ASBR <- vector(mode = "list", length = length(places))
names(ASBR) <- places
for (i in 1:length(places)) {
ASBRi <- outer(ASBRn[i, ], TFR[i, ], FUN = "*")
SRBi <- rep(SRB[i], length = dim(ASBRi)[2])
ASBRi <- rbind(SRBi, ASBRi)
rownames(ASBRi)[1] <- "SRB"
colnames(ASBRi) <- pcycles
ASBR[[i]] <- ASBRi
}
ASBR <- lapply(ASBR, round, 4)
ASBR
saveRDS(ASBR, paste0(path2inputs, "ASBR/ASBR.rds"))
metadata <- readRDS("metadata.rds")
path2inputs <- metadata$paths$path2inputs
source(paste0(metadata$paths$path2R, "projection.R"))
# Parameters for reading 2019 census migration data
pathfile  <- paste0(path2inputs, "NIMR/src/NIMsource2019.csv")  # Note NIMR changed to NIM
AgeGroups <- getAG(5, 95)
dataColsM <- 51:97
dataColsF <- 99:145
dataRows  <- 60:106
increment <- 50
# Read in 2019 data
MigData2019 <- import.MigData(pathfile, AgeGroups, dataColsM, dataColsF, dataRows, increment)
dim(MigData2019)  # [1] 47 47  2 20
dimnames(MigData2019)
# Check 2019 data (note columns EP:JK "intersex")
male <- apply(MigData2019, 1:3, sum)[, , "Male"]
diag(male)[c(1:3, 45:47)]     # Check!
female <- apply(MigData2019, 1:3, sum)[, , "Female"]
diag(female)[c(1:3, 45:47)]   # Check!
both <- male + female
pop <- sum(both)  # [1] 45998420 (less age 0)
diag(both) <- 0
mig <- sum(both)  # 3397484
mig / pop  # [1] 0.07386088
# Save 2019 to .rds
pathfile <- paste0(path2inputs, "NIMR/MigData2019.rds")
saveRDS(MigData2019, pathfile)
# Parameters for reading 2009 census migration data
pathfile  <- paste0(path2inputs, "NIMR/src/NIMsource2009.csv")
AgeGroups <- getAG(5, 65)
dataColsM <- 51:97
dataColsF <- 99:145
dataRows  <- 60:106
increment <- 50
# Read in 2009 data
MigData2009 <- import.MigData(pathfile, AgeGroups, dataColsM, dataColsF, dataRows, increment)
dim(MigData2009)  # [1] 47 47  2 14
# Check 2009 data (note columns EP:JK "intersex")
male <- apply(MigData2009, 1:3, sum)[, , "Male"]
diag(male)[c(1:3, 45:47)]     # Check!
female <- apply(MigData2009, 1:3, sum)[, , "Female"]
diag(female)[c(1:3, 45:47)]   # Check!
both <- male + female
pop <- sum(both)
diag(both) <- 0
mig <- sum(both)
mig / pop  # [1] 0.0353481
# Save 2009 to .rds
pathfile <- paste0(path2inputs, "NIMR/MigData2009.rds")
saveRDS(MigData2009, pathfile)
# Ratio of 2019 rate to 2009 rate
0.07386088 / 0.0353481  # [1] 2.089529
metadata <- readRDS("metadata.rds")
path2inputs <- metadata$paths$path2inputs
source(paste0(metadata$paths$path2R, "projection.R"))
# STEP 1: Calculate net internal migration (NIM5x1) numbers for 2019
MigData <- readRDS(paste0(path2inputs, "NIMR/MigData2019.rds"))  # INPUT
dim(MigData)  # [1] 47 47  2 20
dimnames(MigData)
MigData[c(1:2, 46:47), c(1:2, 46:47), , ]  # Note diagonals non-zero
# Initialize NIM matrix
ASDrows <- metadata$age$ASDrows
subareas <- metadata$place$subareas
NIM <- matrix(0, nrow = length(ASDrows), ncol = length(subareas))
rownames(NIM) <- ASDrows
colnames(NIM) <- subareas
calculateNIM <- function(MigMatrix){
diag(MigMatrix) <- 0
In <- apply(MigMatrix, 1, sum)
Out <- apply(MigMatrix, 2, sum)
NetMigrants <-  In - Out
return(NetMigrants)
}
# Populate NIM matrix
n <- dim(NIM)[1] / 2
for (i in 1:n) {
MigMatrix <- MigData[, , "Female", i]
NIM[i, ] <- calculateNIM(MigMatrix)
}
for (i in 1:n) {
MigMatrix <- MigData[, , "Male", i]
NIM[n + i, ] <- calculateNIM(MigMatrix)
}
# View(NIM)  # Some zero cells, but we deal with this later
# Look at rates
POP <- readRDS(paste0(path2inputs, "BaseASD/census2019asd5.rds"))
NIMR <- NIM /POP[, -1]
# View(round(NIMR, 2))
# Problem with rates at older ages, they are too high and they go UP
# For now, a quick fix, . . .
move.toward.zero <- function(x) {
for (i in 2:length(x)) {
if (abs(x[i]) > abs(x[i - 1])) {x[i] <- 0.8 * x[i - 1]}
}
return(x)
}
for (j in 1:47) {
county <- colnames(NIMR)[j]
NIMR[11:20, j] <- move.toward.zero(NIMR[11:20, j])
NIMR[31:40, j] <- move.toward.zero(NIMR[31:40, j])
}
# View(round(NIMR, 4))
saveRDS(NIMR, paste0(path2inputs, "NIMR/NIMR5x1.rds"))
# Plot to inspect results
pathfile <- paste0(path2inputs, "NIMR/plots/NIMR5x1.pdf")
pdf(pathfile, onefile = TRUE)
for (i in 1:47) {
county <- colnames(NIMR)[i]
sex <- "Female"
y <- NIMR[1:20, i]
x <- 5 * 1:length(y) - 2.5
plot(x, y, xlim = c(0, 100), xlab = "Age", ylab = "NIMR")
lines(x, y)
lines(c(0, 100), c(0,0))
text(80, mean(y), paste(j, county, sex))
sex <- "Male"
y <- NIMR[20 + 1:20, i]
x <- 5 * 1:length(y) - 2.5
plot(x, y, xlim = c(0, 100), xlab = "Age", ylab = "NIMR")
lines(x, y)
lines(c(0, 100), c(0,0))
text(80, mean(y), paste(j, county, sex))
}
dev.off()
# Now adjust NIM (numbers!) accordingly
NIM5x1 <- round(POP[, -1] * NIMR, 0)
# View(NIM5x1)
saveRDS(NIM5x1, paste0(path2inputs, "NIMR/NIM5x1.rds"))
write.csv(NIM5x1, paste0(path2inputs, "NIMR/NIM5x1.csv"))
# STEP 2: Interpolate NIM (5x1) to single years (1x1)
NIM5x1 <- readRDS(paste0(path2inputs, "NIMR/NIM5x1.rds"))
ADrows <- getAG(1, 95)
length(ADrows)  # 96
ASDrows <- c(paste0("f", ADrows), paste0("m", ADrows))
NIM1x1 <- matrix(0, nrow = length(ASDrows), ncol = dim(NIM5x1)[2])
rownames(NIM1x1) <- ASDrows
colnames(NIM1x1) <- colnames(NIM5x1)
for (j in 1:dim(NIM1x1)[2]) {
ad5 <- NIM5x1[1:20, j]
k <- rep(1, times = length(ad5) - 1)
NIM1x1[1:96, j] <- modified.midpoint.interpolation(ad5, k)$table2[, "y3+"]
ad5 <- NIM5x1[20 + 1:20, j]
k <- rep(1, times = length(ad5) - 1)
NIM1x1[96 + 1:96, j] <- modified.midpoint.interpolation(ad5, k)$table2[, "y3+"]
cat(paste0(" . ", j))
}
NIM1x1 <- round(NIM1x1, 0)
# View(NIM1x1)
# Impute zero values 95+ (jump between 94 and 95+ no good)
for (i in 1:length(subareas)) {
NIM1x1[c(96, 192), i] <- 0
}
# View(round(NIM1x1, 0))
saveRDS(NIM1x1, paste0(path2inputs, "NIMR/NIM1x1.rds"))
write.csv(NIM1x1, paste0(path2inputs, "NIMR/NIM1x1.csv"))
# STEP 3: Plot interpolated single year distributions
pathfile <- paste0(path2inputs, "NIMR/plots/NIM1x1.pdf")
pdf(file = pathfile, onefile = TRUE)
n1 <- (dim(NIM5x1)[1] / 2)
n2 <- (dim(NIM1x1)[1] / 2)
for (j in 1:dim(NIM1x1)[2]) {
county <- colnames(NIM1x1)[j]
sex <- "female"
y <- NIM1x1[1:(n2 - 1), j]  # Do not plot oeg
x <- 1:length(y) - 0.5
plot(x, y, xlim = c(0, 100))
lines(x, y)
lines(c(0, 100), c(0, 0))
y <- NIM5x1[1:(n1 - 1), j] / 5
x <- 5 * 1:length(y) - 2.5
points(x, y, cex = 2, pch = 16, col = gray.colors(1))
text(80, mean(y), paste(j, county, sex))
sex <- "male"
y <- NIM1x1[n2 + 1:(n2 - 1), j]
x <- 1:length(y) - 0.5
plot(x, y, xlim = c(0, 100))
lines(x, y)
lines(c(0, 100), c(0, 0))
y <- NIM5x1[n1 + 1:(n1 - 1), j] / 5  # Do not plot oeg
x <- 5 * 1:length(y) - 2.5
points(x, y, cex = 2, pch = 16, col = gray.colors(1))
text(80, mean(y), paste(j, county, sex))
}
dev.off()
# Now study the plots!
# Now study the plots!
# Now study the plots!
# Now study the plots!
# Now study the plots!
# Now study the plots!
# Now study the plots!
metadata <- readRDS("metadata.rds")
path2inputs <- metadata$paths$path2inputs
source(paste0(metadata$paths$path2R, "projection.R"))
# STEP 1: Identify net out-migration counties and net in-migration counties
# Calculate total net migrants for each county
NIM <- readRDS(paste0(path2inputs, "NIMR/NIM5x1.rds"))
NIMtotal <- apply(NIM, 2, sum)
NIMtotal
# Net out-migration counties
countiesOUT <- names(NIMtotal[NIMtotal < 0])
countiesOUT
length(countiesOUT)
saveRDS(countiesOUT, paste0(path2inputs, "NIMR/countiesOUT.rds"))
# Net in-migration counties
countiesIN <- names(NIMtotal[NIMtotal > 0])
countiesIN
length(countiesIN)
saveRDS(countiesIN, paste0(path2inputs, "NIMR/countiesIN.rds"))
# STEP 2: Calculate total female and male net migrants in out-migration counties
# and in-migration counties
NIMsc <- matrix(0, nrow = 2, ncol = 47)  # sc=BY SEX AND COUNTYBy sex and county
rownames(NIMsc) <- c("Female", "Male")
colnames(NIMsc) <- colnames(NIM)
NIMsc[1, ] <- apply(NIM[1:20, ], 2, sum)
NIMsc[2, ] <- apply(NIM[21:40, ], 2, sum)
NIMout <- apply(NIMsc[, countiesOUT], 1, sum)
NIMin <- apply(NIMsc[, countiesIN], 1, sum)
NIM1yr <- cbind(NIMout, NIMin)
NIM1yr
# STEP 3: Create corresponding matrix from LTCSRMig spreadsheets applied
# to 2009 and 2019 age-sex distributions
oeg.out <- 80
POP <- readRDS(paste0(path2inputs, "BaseASD/census2019asd5.rds"))
POP2019 <- reducePOP(POP, oeg.out)
POP <- readRDS(paste0(path2inputs, "BaseASD/census2009asd5.rds"))
POP2009 <- reducePOP(POP, oeg.out)
# Calculate aggregate age-sex distributions for NetOut and NetIn counties
POP2009out <- apply(POP2009[, countiesOUT], 1, sum)
POP2019out <- apply(POP2019[, countiesOUT], 1, sum)
POP2009in <- apply(POP2009[, countiesIN], 1, sum)
POP2019in <- apply(POP2019[, countiesIN], 1, sum)
LTCSRMigIn <- cbind(POP2009[, 1], POP2019[, 1],
POP2009out , POP2019out, POP2009in, POP2019in)
colnames(LTCSRMigIn)[1:2] <- c("POP2009tot", "POP2019tot")
LTCSRMigIn
write.csv(LTCSRMigIn, paste0(path2inputs, "NIMR/LTCSRMigInputs.csv"))
# STEP 3B: Estimate net migration using LTCSRMig spreadsheets for females and
# males for out-migration counties and in-migration counties, enter results
LTCSRMig <- NIM1yr
LTCSRMig[, ] <- 0
LTCSRMig[1, ] <- c(-151948, 126785)
LTCSRMig[2, ] <- c(-143151, 130201)
LTCSRMig
# STEP 4: Calculate adjustment factors
AdjFac <- round(LTCSRMig / NIM1yr, 3)
AdjFac
saveRDS(AdjFac, paste0(path2inputs, "NIMR/AdjFac.rds"))
metadata <- readRDS("metadata.rds")
source(paste0(metadata$paths$path2R, "projection.R"))
ASDrows <- metadata$age$ASDrows
subareas <- metadata$place$subareas
path2inputs <- metadata$paths$path2inputs
# Calculate NIM5x5 directly from census 1 year ago numbers
NIM1x1 <- readRDS(paste0(path2inputs, "NIMR/NIM1x1.rds"))
NIM5x5 <- calculate.NIM5x5(NIM1x1, md = metadata)
ASD5 <- readRDS(paste0(path2inputs, "BaseASD/census2019asd5.rds"))
NIMR5x5 <- NIM5x5 / ASD5[, -1]  # 1st column of ASD5 is Kenya
NIMR5x5 <- round(NIMR5x5, 3)
# View(NIMR5x5)  # Rising rates over age 65 unacceptable
NIMR5x5 <- impute.NIMR5x5.65plus(NIMR5x5, Fac = 0.4)
NIMR5x5 <- round(NIMR5x5, 4)  # Some rates < -1
NIMR5x5[NIMR5x5 < -1] <- -1  # Replace any cells < -1 by -1
# View(NIMR5x5)
write.csv(NIMR5x5, paste0(path2inputs, "NIMR/NIMR5x5.csv"))
# ASSUMPTION B
NIMRb <- calculate.NIMR(NIMR5x5, md = metadata)
saveRDS(NIMRb, paste0(path2inputs, "NIMR/NIMRb.rds"))
# ASSUMPTION A
NIMRa <- lapply(NIMRb, function(x){x[ , ] <- 0; return(x)})
saveRDS(NIMRa, paste0(path2inputs, "NIMR/NIMRa.rds"))
# ASSUMPTION C
# NIMRc Adjust NIM5x5 by LTSCRMig adjustment factors and recalculate NIMR
AdjFac <- readRDS(paste0(path2inputs, "NIMR/AdjFac.rds"))
countiesOUT <- readRDS(paste0(path2inputs, "NIMR/countiesOUT.rds"))
countiesIN <- readRDS(paste0(path2inputs, "NIMR/countiesIN.rds"))
NIM5x5[1:20, countiesOUT] <-
NIM5x5[1:20, countiesOUT] * AdjFac["Female", "NIMout"]
NIM5x5[20 + 1:20, countiesOUT] <-
NIM5x5[20 + 1:20, countiesOUT] * AdjFac["Male",   "NIMout"]
NIM5x5[1:20, countiesIN] <-
NIM5x5[1:20, countiesIN] * AdjFac["Female", "NIMin"]
NIM5x5[20 + 1:20, countiesIN]  <-
NIM5x5[20 + 1:20, countiesIN] * AdjFac["Male", "NIMin"]
ASD5 <- readRDS(paste0(path2inputs, "BaseASD/census2019asd5.rds"))
NIMR5x5 <- NIM5x5 / ASD5[, -1]  # 1st column of ASD5 is Kenya
# View(round(NIMR5x5, 1))  # Rising rates over age 65 unacceptable
NIMR5x5 <- impute.NIMR5x5.65plus(NIMR5x5, Fac = 0.4)
NIMR5x5 <- round(NIMR5x5, 4)
# View(NIMR5x5)
NIMRc <- calculate.NIMR(NIMR5x5, md = metadata)
saveRDS(NIMRc, paste0(path2inputs, "NIMR/NIMRc.rds"))
# ASSUMPTION D
# Introduce trend to reverse 2009-2019 increase
# Crude Net Migration Rate doubled between 2009 and 2019
# Reverse this increase between pcycle1 and pcycle3
introduce.trend <- function(NIMRi) {
# NIMRi is component of NIMR
NIMRi.out <- NIMRi
NIMRi.out[, 2] <- NIMRi[, 1] * sqrt(0.5)
NIMRi.out[, 3:5] <- NIMRi[, 3:5] * 0.5
return(NIMRi.out)
}
NIMRd <- lapply(NIMRc, introduce.trend)
NIMRd <- lapply(NIMRd, round, 4)
# View(NIMRd[[2]])
saveRDS(NIMRd, paste0(path2inputs, "NIMR/NIMRd.rds"))
# PREPARATORY STEPS
metadata <- readRDS("metadata.rds")
source(paste0(path2R, "projection.R"))
path2inputs <- metadata$paths$path2inputs
path2outputs <- metadata$paths$path2outputs
path2R <- metadata$paths$path2R
places  <- metadata$place$places
pcycles <- metadata$time$pcycles
place <- places[1]
BaseASD <- readRDS(paste0(path2inputs, "BaseASD/BaseASD.rds"))  # View(BaseASD)
nLx <- readRDS(paste0(path2inputs, "nLx/nLx.rds"))
ASBR <- readRDS(paste0(path2inputs, "ASBR/ASBR.rds"))
NIMRa <- readRDS(paste0(path2inputs, "NIMR/NIMRa.rds"))  # No migration
NIMRb <- readRDS(paste0(path2inputs, "NIMR/NIMRb.rds"))  # Migration raw
NIMRc <- readRDS(paste0(path2inputs, "NIMR/NIMRc.rds"))  # Migration adjusted
NIMRd <- readRDS(paste0(path2inputs, "NIMR/NIMRd.rds"))  # Add decline
# PROJECTION 1: No migration
NIMR <- NIMRa
proj1 <- calculate.projections(places, BaseASD, nLx, ASBR, NIMR, md = metadata)
saveRDS(proj1, paste0(path2outputs, "projections/proj1.rds"))
proj1Totals <- t(sapply(proj1, get.projTotals))
proj1Totals <- sort.PlacesByGrowth(proj1Totals)
proj1Totals
write.csv(proj1Totals, paste0(path2outputs, "projections/proj1Totals.csv"))
# PROJECTION 2: Migration raw
NIMR   <- readRDS(paste0(path2inputs, "NIMR/NIMRb.rds"))
proj2 <- calculate.projections(places, BaseASD, nLx, ASBR, NIMR, md = metadata)
saveRDS(proj2, paste0(path2outputs, "projections/proj2.rds"))
proj2Totals <- t(sapply(proj2, get.projTotals))
proj2Totals <- sort.PlacesByGrowth(proj2Totals)
proj2Totals
write.csv(proj2Totals, paste0(path2outputs, "projections/proj2Totals.csv"))
# PROJECTION 3: Migration adjusted by LTCSRTMig census survival estimates
NIMR  <- readRDS(paste0(path2inputs, "NIMR/NIMRc.rds"))
proj3 <- calculate.projections(places, BaseASD, nLx, ASBR, NIMR, md = metadata)
saveRDS(proj3, paste0(path2outputs, "projections/proj3.rds"))
proj3Totals <- t(sapply(proj3, get.projTotals))
proj3Totals <- sort.PlacesByGrowth(proj3Totals)
proj3Totals
write.csv(proj3Totals, paste0(path2outputs, "projections/proj3Totals.csv"))
# PROJECTION 4: Migration adjusted with decline
NIMR  <- readRDS(paste0(path2inputs, "NIMR/NIMRd.rds"))
proj4 <- calculate.projections(places, BaseASD, nLx, ASBR, NIMR, md = metadata)
saveRDS(proj4, paste0(path2outputs, "projections/proj4.rds"))
proj4Totals <- t(sapply(proj4, get.projTotals))
proj4Totals <- sort.PlacesByGrowth(proj4Totals)
proj4Totals
write.csv(proj4Totals, paste0(path2outputs, "projections/proj4Totals.csv"))
rm(list = ls())
metadata <- readRDS("metadata.rds")
path2inputs <- metadata$paths$path2inputs
path2outputs <- metadata$paths$path2outputs
path2R <- metadata$paths$path2R
source(paste0(path2R, "projection.R"))
places  <- metadata$place$places
pcycles <- metadata$time$pcycles
BaseASD <- readRDS(paste0(path2inputs, "BaseASD/BaseASD.rds"))  # View(BaseASD)
nLx     <- readRDS(paste0(path2inputs, "nLx/nLx.rds"))
ASBR    <- readRDS(paste0(path2inputs, "ASBR/ASBR.rds"))
NIMR   <- readRDS(paste0(path2inputs, "NIMR/NIMRd.rds"))
projections <- vector(mode = "list", length = length(places))
names(projections) <- places
projections.init <- projections
for (i in 1:length(projections)) {
place <- names(projections)[i]
projections.init[[i]] <-
initialize.projection.pframes(place, BaseASD, nLx, ASBR, NIMR)
projections[[i]] <- calculate.projection(projections.init[[i]])
}
# National Projection
np <- projections$Kenya
cols <- c("ASDin", "Deaths", "Births", "Survivors", "ASDout")
for (i in 1:length(np)) {
np[[i]][, cols] <- round(np[[i]][, cols], 0)
}
np  # These are the numbers we want subnational projections to be consistent with
# Consistent subnational projections
snpi <- transpose.ListMatrix(projections.init[2:48])  # This needs explaining
snp <- calculate.consistent.projections(np, snpi)
# Consistency parameters
rMatrixList <- vector(mode = "list", length = length(snp))
names(rMatrixList) <- pcycles
for (i in 1:length(snp)){
rMatrixList[[i]] <- attr(snp[[i]], "rMatrix")
}
lapply(rMatrixList, round, 3)
# Look at county population change
snp <- transpose.ListMatrix(snp)  # This needs explaining
projectionTotals <- t(sapply(snp, get.projTotals))
projectionTotals <- sort.PlacesByGrowth(projectionTotals)
projectionTotals
write.csv(projectionTotals, paste0(path2outputs, "projections/projectionTotals.csv"))
# Look at components of change for counties
get.ComponentsMatrix(snp$Kwale)
get.ComponentsMatrix(snp$Kilifi)
get.ComponentsMatrix(snp$`Tana River`)
get.ComponentsMatrix(snp$`Taita-Taveta`)
get.ComponentsMatrix(snp$Garissa)
get.ComponentsMatrix(snp$Baringo)
get.ComponentsMatrix(snp$Vihiga)
